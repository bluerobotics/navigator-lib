<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="A library that makes linear color calculations and conversion easy and accessible for anyone. It uses the type system to enforce correctness and to avoid mistakes, such as mixing incompatible color types."><title>palette - Rust</title><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceSerif4-Regular-46f98efaafac5295.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/FiraSans-Regular-018c141bf0843ffd.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/FiraSans-Medium-8f9a781e4970d388.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceSerif4-Bold-a2c9cd1067f8b328.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2"><link rel="stylesheet" href="../static.files/normalize-76eba96aa4d2e634.css"><link rel="stylesheet" href="../static.files/rustdoc-cb6f1f67f1bcd037.css" id="mainThemeStyle"><meta name="rustdoc-vars" data-root-path="../" data-static-root-path="../static.files/" data-current-crate="palette" data-themes="" data-resource-suffix="" data-rustdoc-version="1.73.0-nightly (864bdf784 2023-07-25)" data-channel="nightly" data-search-js="search-6dfdfced5eff6596.js" data-settings-js="settings-de11bff964e9d4e5.js" data-settings-css="settings-8c76f75bfb6bd192.css" data-theme-light-css="light-6d2c9675f3d09c26.css" data-theme-dark-css="dark-45ceb8f2e522f4d1.css" data-theme-ayu-css="ayu-fd19013d6ce078bf.css" ><script src="../static.files/storage-db41da1a38ea3cb8.js"></script><script defer src="../crates.js"></script><script defer src="../static.files/main-0795b7d26be81095.js"></script><noscript><link rel="stylesheet" media="(prefers-color-scheme:light)" href="../static.files/light-6d2c9675f3d09c26.css"><link rel="stylesheet" media="(prefers-color-scheme:dark)" href="../static.files/dark-45ceb8f2e522f4d1.css"><link rel="stylesheet" href="../static.files/noscript-cffde32267a19fd6.css"></noscript><link rel="alternate icon" type="image/png" href="../static.files/favicon-16x16-8b506e7a72182f1c.png"><link rel="alternate icon" type="image/png" href="../static.files/favicon-32x32-422f7d1d52889060.png"><link rel="icon" type="image/svg+xml" href="../static.files/favicon-2c020d218678b618.svg"></head><body class="rustdoc mod crate"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle">&#9776;</button><a class="logo-container" href="../palette/index.html"><img class="rust-logo" src="../static.files/rust-logo-151179464ae7ed46.svg" alt="logo"></a><h2></h2></nav><nav class="sidebar"><a class="logo-container" href="../palette/index.html"><img class="rust-logo" src="../static.files/rust-logo-151179464ae7ed46.svg" alt="logo"></a><h2 class="location"><a href="#">Crate palette</a></h2><div class="sidebar-elems"><ul class="block"><li class="version">Version 0.6.1</li><li><a id="all-types" href="all.html">All Items</a></li></ul><section><ul class="block"><li><a href="#reexports">Re-exports</a></li><li><a href="#modules">Modules</a></li><li><a href="#structs">Structs</a></li><li><a href="#traits">Traits</a></li><li><a href="#functions">Functions</a></li><li><a href="#types">Type Definitions</a></li><li><a href="#derives">Derive Macros</a></li></ul></section></div></nav><main><div class="width-limiter"><nav class="sub"><form class="search-form"><span></span><input class="search-input" name="search" aria-label="Run search in the documentation" autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"><div id="help-button" title="help" tabindex="-1"><a href="../help.html">?</a></div><div id="settings-menu" tabindex="-1"><a href="../settings.html" title="settings"><img width="22" height="22" alt="Change settings" src="../static.files/wheel-7b819b6101059cd0.svg"></a></div></form></nav><section id="main-content" class="content"><div class="main-heading"><h1>Crate <a class="mod" href="#">palette</a><button id="copy-path" title="Copy item path to clipboard"><img src="../static.files/clipboard-7571035ce49a181d.svg" width="19" height="18" alt="Copy item path"></button></h1><span class="out-of-band"><a class="src" href="../src/palette/lib.rs.html#1-766">source</a> · <button id="toggle-all-docs" title="collapse all docs">[<span>&#x2212;</span>]</button></span></div><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>A library that makes linear color calculations and conversion easy and
accessible for anyone. It uses the type system to enforce correctness and
to avoid mistakes, such as mixing incompatible color types.</p>
<h2 id="its-never-just-rgb"><a href="#its-never-just-rgb">It’s Never “Just RGB”</a></h2>
<p>Colors in images are often “gamma corrected”, or converted using some
non-linear transfer function into a format like sRGB before being stored or
displayed. This is done as a compression method and to prevent banding; it’s
also a bit of a legacy from the ages of the CRT monitors, where the output
from the electron gun was non-linear. The problem is that these formats are
<em>non-linear color spaces</em>, which means that many operations that you may
want to perform on colors (addition, subtraction, multiplication, linear
interpolation, etc.) will work unexpectedly when performed in such a
non-linear color space. Thus, the compression has to be reverted to restore
linearity and ensure that many operations on the colors behave as expected.</p>
<p>For example, this does not work:</p>

<div class="example-wrap compile_fail"><a href="#" class="tooltip" title="This example deliberately fails to compile">ⓘ</a><pre class="rust rust-example-rendered"><code><span class="comment">// An alias for Rgb&lt;Srgb&gt;, which is what most pictures store.
</span><span class="kw">use </span>palette::Srgb;

<span class="kw">let </span>orangeish = Srgb::new(<span class="number">1.0</span>, <span class="number">0.6</span>, <span class="number">0.0</span>);
<span class="kw">let </span>blueish = Srgb::new(<span class="number">0.0</span>, <span class="number">0.2</span>, <span class="number">1.0</span>);
<span class="kw">let </span>whatever_it_becomes = orangeish + blueish; <span class="comment">// Does not compile</span></code></pre></div>
<p>Instead, they have to be made linear before adding:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="comment">// An alias for Rgb&lt;Srgb&gt;, which is what most pictures store.
</span><span class="kw">use </span>palette::{Pixel, Srgb};

<span class="kw">let </span>orangeish = Srgb::new(<span class="number">1.0</span>, <span class="number">0.6</span>, <span class="number">0.0</span>).into_linear();
<span class="kw">let </span>blueish = Srgb::new(<span class="number">0.0</span>, <span class="number">0.2</span>, <span class="number">1.0</span>).into_linear();
<span class="kw">let </span>whatever_it_becomes = orangeish + blueish;

<span class="comment">// Encode the result back into sRGB and create a byte array
</span><span class="kw">let </span>pixel: [u8; <span class="number">3</span>] = Srgb::from_linear(whatever_it_becomes)
    .into_format()
    .into_raw();</code></pre></div>
<p>See the <a href="rgb/index.html" title="mod palette::rgb">rgb</a> module for a deeper dive into RGB and (non-)linearity.</p>
<h2 id="color-spaces"><a href="#color-spaces">Color Spaces</a></h2>
<p>“RGB” and other tristimulus based spaces like CIE Xyz are probably the most
widely known color spaces. These spaces are great when you want to perform
physically based math on color (like in a 2D or 3D rendering program) but
there are also color spaces that are not defined in terms of tristimulus
values.</p>
<p>You have probably used a color picker with a rainbow wheel and a brightness
slider. That may have been an HSV or an HSL color picker, where the color is
encoded as hue, saturation and brightness/lightness. Even though these
spaces are defined using 3 values, they <em>aren’t</em> based on tristimulus
values, since those three values don’t have a direct relation to human
vision (i.e. our L, M, and S cones).
Such color spaces are excellent when it comes to humans intuitively
selecting color values, and as such are the go-to choice when this
interaction is needed. They can then be converted into other color spaces
to perform modifications to them.</p>
<p>There’s also a group of color spaces that are designed to be perceptually
uniform, meaning that the perceptual change is equal to the numerical
change. An example of this is the CIE L*a*b* color space. These color
spaces are excellent when you want to “blend” between colors in a
<em>perceptually pleasing</em> manner rather than based on <em>physical light intensity</em>.</p>
<p>Selecting the proper color space can have a big impact on how the resulting
image looks (as illustrated by some of the programs in <code>examples</code>), and
Palette makes the conversion between them as easy as a call to <code>from_color</code>
or <code>into_color</code>.</p>
<p>This example takes an sRGB color, converts it to CIE L*C*h°, a color space
similar to the colloquial HSL/HSV color spaces, shifts its hue by 180° and
converts it back to RGB:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>palette::{FromColor, Hue, IntoColor, Lch, Srgb};

<span class="kw">let </span>lch_color: Lch = Srgb::new(<span class="number">0.8</span>, <span class="number">0.2</span>, <span class="number">0.1</span>).into_color();
<span class="kw">let </span>new_color = Srgb::from_color(lch_color.shift_hue(<span class="number">180.0</span>));</code></pre></div>
<h2 id="transparency"><a href="#transparency">Transparency</a></h2>
<p>There are many cases where pixel transparency is important, but there are
also many cases where it becomes a dead weight, if it’s always stored
together with the color, but not used. Palette has therefore adopted a
structure where the transparency component (alpha) is attachable using the
<a href="struct.Alpha.html" title="struct palette::Alpha"><code>Alpha</code></a> type, instead of having copies of each color
space.</p>
<p>This approach comes with the extra benefit of allowing operations to
selectively affect the alpha component:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>palette::{LinSrgb, LinSrgba};

<span class="kw">let </span><span class="kw-2">mut </span>c1 = LinSrgba::new(<span class="number">1.0</span>, <span class="number">0.5</span>, <span class="number">0.5</span>, <span class="number">0.8</span>);
<span class="kw">let </span>c2 = LinSrgb::new(<span class="number">0.5</span>, <span class="number">1.0</span>, <span class="number">1.0</span>);

c1.color = c1.color * c2; <span class="comment">//Leave the alpha as it is
</span>c1.blue += <span class="number">0.2</span>; <span class="comment">//The color components can easily be accessed
</span>c1 = c1 * <span class="number">0.5</span>; <span class="comment">//Scale both the color and the alpha</span></code></pre></div>
<h2 id="a-basic-workflow"><a href="#a-basic-workflow">A Basic Workflow</a></h2>
<p>The overall workflow can be divided into three steps, where the first and
last may be taken care of by other parts of the application:</p>
<div class="example-wrap"><pre class="language-text"><code>Decoding -&gt; Processing -&gt; Encoding
</code></pre></div><h3 id="1-decoding"><a href="#1-decoding">1. Decoding</a></h3>
<p>Find out what the source format is and convert it to a linear color space.
There may be a specification, such as when working with SVG or CSS.</p>
<p>When working with RGB or gray scale (luma):</p>
<ul>
<li>
<p>If you are asking your user to enter an RGB value, you are in a gray zone
where it depends on the context. It’s usually safe to assume sRGB, but
sometimes it’s already linear.</p>
</li>
<li>
<p>If you are decoding an image, there may be some meta data that gives you
the necessary details. Otherwise it’s most commonly sRGB. Usually you
will end up with a slice or vector with RGB bytes, which can easily be
converted to Palette colors:</p>
</li>
</ul>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>palette::{Srgb, Pixel};

<span class="comment">// This works for any (even non-RGB) color type that can have the
// buffer element type as component.
</span><span class="kw">let </span>color_buffer: <span class="kw-2">&amp;mut </span>[Srgb&lt;u8&gt;] = Pixel::from_raw_slice_mut(<span class="kw-2">&amp;mut </span>image_buffer);</code></pre></div>
<ul>
<li>If you are getting your colors from the GPU, in a game or other graphical
application, or if they are otherwise generated by the application, then
chances are that they are already linear. Still, make sure to check that
they are not being encoded somewhere.</li>
</ul>
<p>When working with other colors:</p>
<ul>
<li>
<p>For HSL, HSV, HWB: Check if they are based on any other color space than
sRGB, such as Adobe or Apple RGB.</p>
</li>
<li>
<p>For any of the CIE color spaces, check for a specification of white point
and light source. These are necessary for converting to RGB and other
colors, that depend on perception and “viewing devices”. Common defaults
are the D65 light source and the sRGB white point. The Palette defaults
should take you far.</p>
</li>
</ul>
<h3 id="2-processing"><a href="#2-processing">2. Processing</a></h3>
<p>When your color has been decoded into some Palette type, it’s ready for
processing. This includes things like blending, hue shifting, darkening and
conversion to other formats. Just make sure that your non-linear RGB is
made linear first (<code>my_srgb.into_linear()</code>), to make the operations
available.</p>
<p>Different color spaced have different capabilities, pros and cons. You may
have to experiment a bit (or look at the example programs) to find out what
gives the desired result.</p>
<h3 id="3-encoding"><a href="#3-encoding">3. Encoding</a></h3>
<p>When the desired processing is done, it’s time to encode the colors back
into some image format. The same rules applies as for the decoding, but the
process reversed.</p>
<h2 id="working-with-raw-data"><a href="#working-with-raw-data">Working with Raw Data</a></h2>
<p>Oftentimes, pixel data is stored in a raw buffer such as a <code>[u8; 3]</code>. The
<a href="encoding/pixel/trait.Pixel.html" title="trait palette::encoding::pixel::Pixel"><code>Pixel</code></a> trait allows for easy interoperation between
Palette colors and other crates or systems. <code>from_raw</code> can be used to
convert into a Palette color, <code>into_format</code> converts from  <code>Srgb&lt;u8&gt;</code> to
<code>Srgb&lt;f32&gt;</code>, and finally <code>into_raw</code> to convert from a Palette color back to
a <code>[u8;3]</code>.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>approx::assert_relative_eq;
<span class="kw">use </span>palette::{Srgb, Pixel};

<span class="kw">let </span>buffer = [<span class="number">255</span>, <span class="number">0</span>, <span class="number">255</span>];
<span class="kw">let </span>raw = Srgb::from_raw(<span class="kw-2">&amp;</span>buffer);
<span class="macro">assert_eq!</span>(raw, <span class="kw-2">&amp;</span>Srgb::&lt;u8&gt;::new(<span class="number">255u8</span>, <span class="number">0</span>, <span class="number">255</span>));

<span class="kw">let </span>raw_float: Srgb&lt;f32&gt; = raw.into_format();
<span class="macro">assert_relative_eq!</span>(raw_float, Srgb::new(<span class="number">1.0</span>, <span class="number">0.0</span>, <span class="number">1.0</span>));

<span class="kw">let </span>raw: [u8; <span class="number">3</span>] = Srgb::into_raw(raw_float.into_format());
<span class="macro">assert_eq!</span>(raw, buffer);</code></pre></div>
</div></details><h2 id="reexports" class="small-section-header"><a href="#reexports">Re-exports</a></h2><ul class="item-table"><li><div class="item-name" id="reexport.Blend"><code>pub use blend::<a class="trait" href="blend/trait.Blend.html" title="trait palette::blend::Blend">Blend</a>;</code></div></li><li><div class="item-name" id="reexport.Gradient"><code>pub use gradient::<a class="struct" href="gradient/struct.Gradient.html" title="struct palette::gradient::Gradient">Gradient</a>;</code></div></li><li><div class="item-name" id="reexport.GammaLuma"><code>pub use luma::<a class="type" href="luma/type.GammaLuma.html" title="type palette::luma::GammaLuma">GammaLuma</a>;</code></div></li><li><div class="item-name" id="reexport.GammaLumaa"><code>pub use luma::<a class="type" href="luma/type.GammaLumaa.html" title="type palette::luma::GammaLumaa">GammaLumaa</a>;</code></div></li><li><div class="item-name" id="reexport.LinLuma"><code>pub use luma::<a class="type" href="luma/type.LinLuma.html" title="type palette::luma::LinLuma">LinLuma</a>;</code></div></li><li><div class="item-name" id="reexport.LinLumaa"><code>pub use luma::<a class="type" href="luma/type.LinLumaa.html" title="type palette::luma::LinLumaa">LinLumaa</a>;</code></div></li><li><div class="item-name" id="reexport.SrgbLuma"><code>pub use luma::<a class="type" href="luma/type.SrgbLuma.html" title="type palette::luma::SrgbLuma">SrgbLuma</a>;</code></div></li><li><div class="item-name" id="reexport.SrgbLumaa"><code>pub use luma::<a class="type" href="luma/type.SrgbLumaa.html" title="type palette::luma::SrgbLumaa">SrgbLumaa</a>;</code></div></li><li><div class="item-name" id="reexport.GammaSrgb"><code>pub use rgb::<a class="type" href="rgb/type.GammaSrgb.html" title="type palette::rgb::GammaSrgb">GammaSrgb</a>;</code></div></li><li><div class="item-name" id="reexport.GammaSrgba"><code>pub use rgb::<a class="type" href="rgb/type.GammaSrgba.html" title="type palette::rgb::GammaSrgba">GammaSrgba</a>;</code></div></li><li><div class="item-name" id="reexport.LinSrgb"><code>pub use rgb::<a class="type" href="rgb/type.LinSrgb.html" title="type palette::rgb::LinSrgb">LinSrgb</a>;</code></div></li><li><div class="item-name" id="reexport.LinSrgba"><code>pub use rgb::<a class="type" href="rgb/type.LinSrgba.html" title="type palette::rgb::LinSrgba">LinSrgba</a>;</code></div></li><li><div class="item-name" id="reexport.Packed"><code>pub use rgb::<a class="struct" href="rgb/struct.Packed.html" title="struct palette::rgb::Packed">Packed</a>;</code></div></li><li><div class="item-name" id="reexport.RgbChannels"><code>pub use rgb::<a class="trait" href="rgb/trait.RgbChannels.html" title="trait palette::rgb::RgbChannels">RgbChannels</a>;</code></div></li><li><div class="item-name" id="reexport.Srgb"><code>pub use rgb::<a class="type" href="rgb/type.Srgb.html" title="type palette::rgb::Srgb">Srgb</a>;</code></div></li><li><div class="item-name" id="reexport.Srgba"><code>pub use rgb::<a class="type" href="rgb/type.Srgba.html" title="type palette::rgb::Srgba">Srgba</a>;</code></div></li><li><div class="item-name" id="reexport.FromColor"><code>pub use convert::<a class="trait" href="convert/trait.FromColor.html" title="trait palette::convert::FromColor">FromColor</a>;</code></div></li><li><div class="item-name" id="reexport.IntoColor"><code>pub use convert::<a class="trait" href="convert/trait.IntoColor.html" title="trait palette::convert::IntoColor">IntoColor</a>;</code></div></li><li><div class="item-name" id="reexport.Pixel"><code>pub use encoding::pixel::<a class="trait" href="encoding/pixel/trait.Pixel.html" title="trait palette::encoding::pixel::Pixel">Pixel</a>;</code></div></li></ul><h2 id="modules" class="small-section-header"><a href="#modules">Modules</a></h2><ul class="item-table"><li><div class="item-name"><a class="mod" href="blend/index.html" title="mod palette::blend">blend</a></div><div class="desc docblock-short">Color blending and blending equations.</div></li><li><div class="item-name"><a class="mod" href="chromatic_adaptation/index.html" title="mod palette::chromatic_adaptation">chromatic_adaptation</a></div><div class="desc docblock-short">Convert colors from one reference white point to another</div></li><li><div class="item-name"><a class="mod" href="convert/index.html" title="mod palette::convert">convert</a></div><div class="desc docblock-short">Traits for converting between color spaces.</div></li><li><div class="item-name"><a class="mod" href="encoding/index.html" title="mod palette::encoding">encoding</a></div><div class="desc docblock-short">Various encoding traits, types and standards.</div></li><li><div class="item-name"><a class="mod" href="float/index.html" title="mod palette::float">float</a></div><div class="desc docblock-short">Floating point trait</div></li><li><div class="item-name"><a class="mod" href="gradient/index.html" title="mod palette::gradient">gradient</a></div><div class="desc docblock-short">Types for interpolation between multiple colors.</div></li><li><div class="item-name"><a class="mod" href="luma/index.html" title="mod palette::luma">luma</a></div><div class="desc docblock-short">Luminance types.</div></li><li><div class="item-name"><a class="mod" href="named/index.html" title="mod palette::named">named</a></div><div class="desc docblock-short">A collection of named color constants. Can be toggled with the <code>&quot;named&quot;</code> and
<code>&quot;named_from_str&quot;</code> Cargo features.</div></li><li><div class="item-name"><a class="mod" href="rgb/index.html" title="mod palette::rgb">rgb</a></div><div class="desc docblock-short">RGB types, spaces and standards.</div></li><li><div class="item-name"><a class="mod" href="white_point/index.html" title="mod palette::white_point">white_point</a></div><div class="desc docblock-short">Defines the tristimulus values of the CIE Illuminants.</div></li></ul><h2 id="structs" class="small-section-header"><a href="#structs">Structs</a></h2><ul class="item-table"><li><div class="item-name"><a class="struct" href="struct.Alpha.html" title="struct palette::Alpha">Alpha</a></div><div class="desc docblock-short">An alpha component wrapper for colors.</div></li><li><div class="item-name"><a class="struct" href="struct.Hsl.html" title="struct palette::Hsl">Hsl</a></div><div class="desc docblock-short">HSL color space.</div></li><li><div class="item-name"><a class="struct" href="struct.Hsluv.html" title="struct palette::Hsluv">Hsluv</a></div><div class="desc docblock-short">HSLuv color space.</div></li><li><div class="item-name"><a class="struct" href="struct.Hsv.html" title="struct palette::Hsv">Hsv</a></div><div class="desc docblock-short">HSV color space.</div></li><li><div class="item-name"><a class="struct" href="struct.Hwb.html" title="struct palette::Hwb">Hwb</a></div><div class="desc docblock-short">HWB color space.</div></li><li><div class="item-name"><a class="struct" href="struct.Lab.html" title="struct palette::Lab">Lab</a></div><div class="desc docblock-short">The CIE L*a*b* (CIELAB) color space.</div></li><li><div class="item-name"><a class="struct" href="struct.LabHue.html" title="struct palette::LabHue">LabHue</a></div><div class="desc docblock-short">A hue type for the CIE L*a*b* family of color spaces.</div></li><li><div class="item-name"><a class="struct" href="struct.Lch.html" title="struct palette::Lch">Lch</a></div><div class="desc docblock-short">CIE L*C*h°, a polar version of <a href="struct.Lab.html" title="struct palette::Lab">CIE L*a*b*</a>.</div></li><li><div class="item-name"><a class="struct" href="struct.Lchuv.html" title="struct palette::Lchuv">Lchuv</a></div><div class="desc docblock-short">CIE L*C*uv h°uv, a polar version of <a href="struct.Lab.html" title="struct palette::Lab">CIE L*u*v*</a>.</div></li><li><div class="item-name"><a class="struct" href="struct.Luv.html" title="struct palette::Luv">Luv</a></div><div class="desc docblock-short">The CIE L*u*v* (CIELUV) color space.</div></li><li><div class="item-name"><a class="struct" href="struct.LuvHue.html" title="struct palette::LuvHue">LuvHue</a></div><div class="desc docblock-short">A hue type for the CIE L*u*v* family of color spaces.</div></li><li><div class="item-name"><a class="struct" href="struct.Oklab.html" title="struct palette::Oklab">Oklab</a></div><div class="desc docblock-short">The <a href="https://bottosson.github.io/posts/oklab/">Oklab color space</a>.</div></li><li><div class="item-name"><a class="struct" href="struct.OklabHue.html" title="struct palette::OklabHue">OklabHue</a></div><div class="desc docblock-short">A hue type for the Oklab color space.</div></li><li><div class="item-name"><a class="struct" href="struct.Oklch.html" title="struct palette::Oklch">Oklch</a></div><div class="desc docblock-short">Oklch, a polar version of <a href="struct.Oklab.html" title="struct palette::Oklab">Oklab</a>.</div></li><li><div class="item-name"><a class="struct" href="struct.RgbHue.html" title="struct palette::RgbHue">RgbHue</a></div><div class="desc docblock-short">A hue type for the RGB family of color spaces.</div></li><li><div class="item-name"><a class="struct" href="struct.Xyz.html" title="struct palette::Xyz">Xyz</a></div><div class="desc docblock-short">The CIE 1931 XYZ color space.</div></li><li><div class="item-name"><a class="struct" href="struct.Yxy.html" title="struct palette::Yxy">Yxy</a></div><div class="desc docblock-short">The CIE 1931 Yxy (xyY)  color space.</div></li></ul><h2 id="traits" class="small-section-header"><a href="#traits">Traits</a></h2><ul class="item-table"><li><div class="item-name"><a class="trait" href="trait.Clamp.html" title="trait palette::Clamp">Clamp</a></div><div class="desc docblock-short">A trait for clamping and checking if colors are within their ranges.</div></li><li><div class="item-name"><a class="trait" href="trait.ColorDifference.html" title="trait palette::ColorDifference">ColorDifference</a></div><div class="desc docblock-short">A trait for calculating the color difference between two colors.</div></li><li><div class="item-name"><a class="trait" href="trait.Component.html" title="trait palette::Component">Component</a></div><div class="desc docblock-short">Common trait for color components.</div></li><li><div class="item-name"><a class="trait" href="trait.ComponentWise.html" title="trait palette::ComponentWise">ComponentWise</a></div><div class="desc docblock-short">Perform a unary or binary operation on each component of a color.</div></li><li><div class="item-name"><a class="trait" href="trait.FloatComponent.html" title="trait palette::FloatComponent">FloatComponent</a></div><div class="desc docblock-short">Common trait for floating point color components.</div></li><li><div class="item-name"><a class="trait" href="trait.FromComponent.html" title="trait palette::FromComponent">FromComponent</a></div><div class="desc docblock-short">Converts from a color component type, while performing the appropriate
scaling, rounding and clamping.</div></li><li><div class="item-name"><a class="trait" href="trait.FromF64.html" title="trait palette::FromF64">FromF64</a></div><div class="desc docblock-short">A trait for infallible conversion from <code>f64</code>. The conversion may be lossy.</div></li><li><div class="item-name"><a class="trait" href="trait.GetHue.html" title="trait palette::GetHue">GetHue</a></div><div class="desc docblock-short">A trait for colors where a hue may be calculated.</div></li><li><div class="item-name"><a class="trait" href="trait.Hue.html" title="trait palette::Hue">Hue</a></div><div class="desc docblock-short">A trait for colors where the hue can be manipulated without conversion.</div></li><li><div class="item-name"><a class="trait" href="trait.IntoComponent.html" title="trait palette::IntoComponent">IntoComponent</a></div><div class="desc docblock-short">Converts into a color component type, while performing the appropriate
scaling, rounding and clamping.</div></li><li><div class="item-name"><a class="trait" href="trait.Mix.html" title="trait palette::Mix">Mix</a></div><div class="desc docblock-short">A trait for linear color interpolation.</div></li><li><div class="item-name"><a class="trait" href="trait.RelativeContrast.html" title="trait palette::RelativeContrast">RelativeContrast</a></div><div class="desc docblock-short">A trait for calculating relative contrast between two colors.</div></li><li><div class="item-name"><a class="trait" href="trait.Saturate.html" title="trait palette::Saturate">Saturate</a></div><div class="desc docblock-short">A trait for colors where the saturation (or chroma) can be manipulated
without conversion.</div></li><li><div class="item-name"><a class="trait" href="trait.Shade.html" title="trait palette::Shade">Shade</a></div><div class="desc docblock-short">The <code>Shade</code> trait allows a color to be lightened or darkened.</div></li><li><div class="item-name"><a class="trait" href="trait.WithAlpha.html" title="trait palette::WithAlpha">WithAlpha</a></div><div class="desc docblock-short">A trait for color types that can have or be given transparency (alpha channel).</div></li></ul><h2 id="functions" class="small-section-header"><a href="#functions">Functions</a></h2><ul class="item-table"><li><div class="item-name"><a class="fn" href="fn.contrast_ratio.html" title="fn palette::contrast_ratio">contrast_ratio</a></div><div class="desc docblock-short">Calculate the ratio between two <code>luma</code> values.</div></li></ul><h2 id="types" class="small-section-header"><a href="#types">Type Definitions</a></h2><ul class="item-table"><li><div class="item-name"><a class="type" href="type.Hsla.html" title="type palette::Hsla">Hsla</a></div><div class="desc docblock-short">Linear HSL with an alpha component. See the <a href="struct.Alpha.html#Hsla" title="struct palette::Alpha"><code>Hsla</code> implementation in
<code>Alpha</code></a>.</div></li><li><div class="item-name"><a class="type" href="type.Hsluva.html" title="type palette::Hsluva">Hsluva</a></div><div class="desc docblock-short">HSLuv with an alpha component. See the <a href="struct.Alpha.html#Hsluva" title="struct palette::Alpha"><code>Hsluva</code> implementation in
<code>Alpha</code></a>.</div></li><li><div class="item-name"><a class="type" href="type.Hsva.html" title="type palette::Hsva">Hsva</a></div><div class="desc docblock-short">Linear HSV with an alpha component. See the <a href="struct.Alpha.html#Hsva" title="struct palette::Alpha"><code>Hsva</code> implementation in
<code>Alpha</code></a>.</div></li><li><div class="item-name"><a class="type" href="type.Hwba.html" title="type palette::Hwba">Hwba</a></div><div class="desc docblock-short">Linear HWB with an alpha component. See the <a href="struct.Alpha.html#Hwba" title="struct palette::Alpha"><code>Hwba</code> implementation in
<code>Alpha</code></a>.</div></li><li><div class="item-name"><a class="type" href="type.Laba.html" title="type palette::Laba">Laba</a></div><div class="desc docblock-short">CIE L*a*b* (CIELAB) with an alpha component. See the <a href="struct.Alpha.html#Laba" title="struct palette::Alpha"><code>Laba</code>
implementation in <code>Alpha</code></a>.</div></li><li><div class="item-name"><a class="type" href="type.Lcha.html" title="type palette::Lcha">Lcha</a></div><div class="desc docblock-short">CIE L*C*h° with an alpha component. See the <a href="struct.Alpha.html#Lcha" title="struct palette::Alpha"><code>Lcha</code> implementation in
<code>Alpha</code></a>.</div></li><li><div class="item-name"><a class="type" href="type.Lchuva.html" title="type palette::Lchuva">Lchuva</a></div><div class="desc docblock-short">CIE L*C*uv h°uv with an alpha component. See the <a href="struct.Alpha.html#Lchuva" title="struct palette::Alpha"><code>Lchuva</code> implementation in
<code>Alpha</code></a>.</div></li><li><div class="item-name"><a class="type" href="type.Luva.html" title="type palette::Luva">Luva</a></div><div class="desc docblock-short">CIE L*u*v* (CIELUV) with an alpha component. See the <a href="struct.Alpha.html#Luva" title="struct palette::Alpha"><code>Luva</code>
implementation in <code>Alpha</code></a>.</div></li><li><div class="item-name"><a class="type" href="type.Mat3.html" title="type palette::Mat3">Mat3</a></div><div class="desc docblock-short">A 9 element array representing a 3x3 matrix.</div></li><li><div class="item-name"><a class="type" href="type.Oklaba.html" title="type palette::Oklaba">Oklaba</a></div><div class="desc docblock-short">Oklab with an alpha component. See the <a href="struct.Alpha.html#Oklaba" title="struct palette::Alpha"><code>Oklaba</code> implementation in
<code>Alpha</code></a>.</div></li><li><div class="item-name"><a class="type" href="type.Oklcha.html" title="type palette::Oklcha">Oklcha</a></div><div class="desc docblock-short">Oklch with an alpha component. See the <a href="struct.Alpha.html#Oklcha" title="struct palette::Alpha"><code>Oklcha</code> implementation in
<code>Alpha</code></a>.</div></li><li><div class="item-name"><a class="type" href="type.Xyza.html" title="type palette::Xyza">Xyza</a></div><div class="desc docblock-short">CIE 1931 XYZ with an alpha component. See the <a href="struct.Alpha.html#Xyza" title="struct palette::Alpha"><code>Xyza</code> implementation in
<code>Alpha</code></a>.</div></li><li><div class="item-name"><a class="type" href="type.Yxya.html" title="type palette::Yxya">Yxya</a></div><div class="desc docblock-short">CIE 1931 Yxy (xyY) with an alpha component. See the <a href="struct.Alpha.html#Yxya" title="struct palette::Alpha"><code>Yxya</code> implementation
in <code>Alpha</code></a>.</div></li></ul><h2 id="derives" class="small-section-header"><a href="#derives">Derive Macros</a></h2><ul class="item-table"><li><div class="item-name"><a class="derive" href="derive.Pixel.html" title="derive palette::Pixel">Pixel</a></div></li><li><div class="item-name"><a class="derive" href="derive.WithAlpha.html" title="derive palette::WithAlpha">WithAlpha</a></div></li></ul></section></div></main></body></html>